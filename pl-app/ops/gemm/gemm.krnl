module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu"} {
  func.func @main_graph(%arg0: memref<64512x512xf32>) -> memref<64512x512xf32> attributes {input_names = ["x"], output_names = ["y"]} {
    %c0 = arith.constant 0 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c512 = arith.constant 512 : index
    %c64512 = arith.constant 64512 : index
    %0 = "krnl.global"() {name = "constant_03", shape = [512, 512]} : () -> memref<512x512xf32>
    %1 = "krnl.global"() {name = "constant_12", shape = [512]} : () -> memref<512xf32>
    %alloc = memref.alloc() {alignment = 128 : i64} : memref<64512x512xf32>
    krnl.memset %alloc, %cst : memref<64512x512xf32>
    %alloc_0 = memref.alloc() {alignment = 128 : i64} : memref<32x256xf32>
    %alloc_1 = memref.alloc() {alignment = 128 : i64} : memref<256x64xf32>
    %2:3 = krnl.define_loops 3
    %loop_block, %loop_local = krnl.block %2#0 32 : (!krnl.loop) -> (!krnl.loop, !krnl.loop)
    %loop_block_2, %loop_local_3 = krnl.block %loop_local 4 : (!krnl.loop) -> (!krnl.loop, !krnl.loop)
    %loop_block_4, %loop_local_5 = krnl.block %2#1 64 : (!krnl.loop) -> (!krnl.loop, !krnl.loop)
    %loop_block_6, %loop_local_7 = krnl.block %loop_local_5 16 : (!krnl.loop) -> (!krnl.loop, !krnl.loop)
    %loop_block_8, %loop_local_9 = krnl.block %2#2 256 : (!krnl.loop) -> (!krnl.loop, !krnl.loop)
    krnl.permute(%loop_block_4, %loop_block_6, %loop_local_7, %loop_block_8, %loop_local_9, %loop_block, %loop_block_2, %loop_local_3) [0, 3, 5, 1, 6, 2, 4, 7] : !krnl.loop, !krnl.loop, !krnl.loop, !krnl.loop, !krnl.loop, !krnl.loop, !krnl.loop, !krnl.loop
    krnl.iterate(%loop_block_4, %loop_block_8) with (%2#1 -> %arg1 = 0 to 512, %2#2 -> %arg2 = 0 to 512, %2#0 -> %arg3 = 0 to 64512){
      %4:2 = krnl.get_induction_var_value(%loop_block_4, %loop_block_8) : (!krnl.loop, !krnl.loop) -> (index, index)
      krnl.copy_to_tile_buffer %alloc_1, %0[%4#0, %4#1], %cst {padToNext = [], tileSize = [], transpose = true} : memref<256x64xf32>, memref<512x512xf32>
      krnl.iterate(%loop_block) with (){
        %5 = krnl.get_induction_var_value(%loop_block) : (!krnl.loop) -> index
        krnl.copy_to_tile_buffer %alloc_0, %arg0[%5, %4#1], %cst {padToNext = [], tileSize = []} : memref<32x256xf32>, memref<64512x512xf32>
        krnl.iterate(%loop_block_6, %loop_block_2) with (){
          %6:2 = krnl.get_induction_var_value(%loop_block_6, %loop_block_2) : (!krnl.loop, !krnl.loop) -> (index, index)
          krnl.matmul %alloc_0[%5, %4#1], %alloc_1[%4#1, %4#0], %alloc[%c0, %c0], (%loop_local_3, %loop_local_7, %loop_local_9), (%6#1, %6#0, %4#1), (%c64512, %c512, %c512) {aTileSize = [], bTileSize = [], cTileSize = [], computeTileSize = [4, 16, 256]} : memref<32x256xf32>, memref<256x64xf32>, memref<64512x512xf32>, (!krnl.loop, !krnl.loop, !krnl.loop)
        }
      }
    }
    %3:2 = krnl.define_loops 2
    krnl.iterate(%3#0, %3#1) with (%3#0 -> %arg1 = 0 to 64512, %3#1 -> %arg2 = 0 to 512){
      %4:2 = krnl.get_induction_var_value(%3#0, %3#1) : (!krnl.loop, !krnl.loop) -> (index, index)
      %5 = krnl.load %alloc[%4#0, %4#1] : memref<64512x512xf32>
      %6 = krnl.load %1[%4#1] : memref<512xf32>
      %7 = arith.addf %5, %6 : f32
      krnl.store %7, %alloc[%4#0, %4#1] : memref<64512x512xf32>
    }
    return %alloc : memref<64512x512xf32>
  }
  "krnl.entry_point"() {func = @main_graph, numInputs = 1 : i32, numOutputs = 1 : i32, signature = "[    { \22type\22 : \22f32\22 , \22dims\22 : [64512 , 512] , \22name\22 : \22x\22 }\0A\0A]\00@[   { \22type\22 : \22f32\22 , \22dims\22 : [64512 , 512] , \22name\22 : \22y\22 }\0A\0A]\00"} : () -> ()
}

